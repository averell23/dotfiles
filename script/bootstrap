#!/usr/bin/env ruby
#
# bootstrap installs things.

require 'digest'
require 'fileutils'
require 'io/console'
require 'json'
require 'socket'

module InstallUtils
  def info(text)
    puts "\r  [ \033[00;34m..\033[0m ] #{text.strip}\n"
  end

  def user(text)
    puts "\r  [ \033[00;33m..\033[0m ] #{text}\n"
  end

  def success(text)
    puts "\r\033[2K  [ \033[00;32mOK\033[0m ] #{text}\n"
  end

  def fail(text)
    puts "\r\033[2K  [ \033[00;32mOK\033[0m ] #{text}\n"
    puts
    exit 1
  end

  def run_bash(file)
    run_command('/usr/bin/env', 'bash', file)
  end

  def run_command(*command)
    IO.popen(command + [:err=>[:child, :out]]) do |io|
      io.each { |line| info line }
    end
  end
end

class DotfileInstall
  include InstallUtils

  def get_mode(file)
    File.exists?(file) or return :link
    @global_mode and return @global_mode

    selection = ''
    while !%w(s S o O b B a).include?(selection)
      user "File already exists: #{file}. What do you want to do?\n[s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all, [a]bort?"
      selection = STDIN.getch
    end
    case selection
    when ?s then :skip
    when ?S then @global_mode = :skip
    when ?o then :overwrite
    when ?O then @global_mode = :overwrite
    when ?b then :backup
    when ?B then @global_mode = :backup
    when ?a then exit 1
    end
  end

  def link_file(target, link)
    case get_mode(link)
    when :skip
      success "Skipped #{link}"
      return
    when :backup
      FileUtils.mv link, "#{link}.backup"
      success "Backed up #{link} to #{link}.backup"
    when :overwrite
      FileUtils.rm link
      success "removed #{link}"
    end
    FileUtils.ln_s File.expand_path(target), link
    success "Linked #{target} to #{link}"
  end

  def run
    Dir['**/*.symlink'].each do |dotfile|
      link = '.' << dotfile.gsub(/^[^\/]*\//, '').gsub('secret.', '').gsub('.symlink', '')
      FileUtils.mkdir_p File.dirname('link')
      link_file dotfile, File.join(ENV['HOME'], link)
    end
  end
end

class Configuration
  include InstallUtils

  attr_reader :id


  def brew_lines(section, prefix)
    @data[section] or return []
    @data[section].map do |element|
      if element.is_a?(Array)
        "#{prefix} \"#{element.first}\", #{element.last}"
      else
        "#{prefix} \"#{element}\""
      end
    end
  end

  def packages ; brew_lines('packages', 'brew')  ; end
  def casks ; brew_lines('casks', 'cask') || [] ; end
  def mas ; brew_lines('mas', 'mas') || [] ; end

  def initialize(id)
    @id = id
  end

  def config_dir
    File.join('.', 'device_configs')
  end

  def ensure_config
    filename = config_file(id)
    return if File.exists?(filename)
    File.open(filename, 'w') do |f|
      f.write(JSON.pretty_generate({
        name: Socket.gethostname.strip,
        packages: [],
        casks: [],
        includes: ['defaults']
      }))
    end
    info "Created new config for this machine: #{filename}"
  end

  def config_file(name)
    File.join(config_dir, "#{name}.json")
  end

  def read_json(name)
    File.open(config_file(name)) { |f| JSON.parse(f.read) }
  end

  def load_includes(include_configs)
    include_configs or return
    include_configs.each do |inc|
      include_data = read_json(inc)
      @data = @data.merge(include_data) do |key, oldval, newval|
        oldval.is_a?(Array) && !(key == 'includes') ? (oldval + newval).uniq : oldval
      end
      load_includes(include_data['includes'])
    end
  end

  def load
    ensure_config
    @data = read_json(id)
    load_includes(@data['includes'])
    self
  end

end

class InstallActions
  include InstallUtils

  attr_reader :config

  def os_name ; @os_name ||= `uname -s`.strip ; end
  def macOS? ; os_name == 'Darwin' ; end

  def serial
    @serial ||= if macOS?
      ioreg = `ioreg -c "IOPlatformExpertDevice"`
      ioreg.match(/\"IOPlatformSerialNumber\" = \"(.*)\"/)[1]
    else
      info "Cannot currently get serial for Linux device"
      "UNKOWN-LINUX"
    end
  end

  def device_id
    Digest::MD5.hexdigest(serial)
  end

  def load_config
    @config = Configuration.new(device_id).load
  end

  def setup_powerline_fonts
    info "Installing powerline fonts"
    run_command 'git', 'submodule', 'init'
    run_command 'git', 'submodule', 'update'
    run_bash "powerline_fonts/install.sh"
  end

  def generate_brewfile(config)
    File.open('Brewfile', 'w') do |f|
      f.puts "# Generated by dotfiles. DO NOT EDIT\n"
      f.puts "cask_args appdir: '/Applications'\n"
      f.puts "tap 'homebrew/bundle'\n"
      %w(packages casks mas).each do |el|
        f.puts
        config.__send__(el).each { |p| f.puts p }
      end
    end
    info "Generated Brewfile"
  end

  def run
    info "Detected #{os_name} with serial #{serial}, device_id #{device_id}"
    load_config
    generate_brewfile(config)
    setup_powerline_fonts if macOS?
    DotfileInstall.new.run
    run_command 'bin/dot'
    success "Installation complete"
  end

  def self.run ; new.run ;end
end

InstallActions.run
